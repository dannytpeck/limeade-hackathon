//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by Sitrion AppBuilder.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//    Please use the partial class files to extend this code.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Globalization;
using System.ComponentModel.DataAnnotations;
using System.Xml.Linq;
using HackathonMicroApp.Service.DataTypes;

namespace HackathonMicroApp.Service.DataTypes
{
	public class Bootstrapper
	{
		private static bool _isInitialized = false;
		
		public static void Initialize()
		{
			if ( !_isInitialized )
			{
				_isInitialized = true;
			}
		}
	}
	
	public static class CollectionExtensions {
		public static ObservableCollection<T> ToObservableCollection<T> ( this IEnumerable<T> coll ) {
			var c = new ObservableCollection<T>();
			
			foreach ( var e in coll )
			{ c.Add ( e ); }
			
			return c;
		}
	}
	
	public static class DateTimeExtensions
	{
		public static string NetDate2SapDate ( this DateTime Date )
		{
			return string.Format ( "{0:yyyyMMdd}", ( object ) Date );
		}
		
		public static string NetDate2SapDate ( this DateTimeOffset Date )
		{
			return string.Format ( "{0:yyyyMMdd}", ( object ) Date );
		}
		
		public static DateTime SapDate2NetDate ( this string Date )
		{
			if ( string.IsNullOrEmpty ( Date ) || Date.Length < 8 || Date == "00000000" )
			{ return DateTime.MinValue; }
			
			if ( Date == "99999999" )
			{ return DateTime.MaxValue; }
			
			DateTime result;
			
			if ( DateTime.TryParseExact ( Date, "yyyyMMdd", ( IFormatProvider ) CultureInfo.InvariantCulture, DateTimeStyles.AssumeLocal, out result ) )
			{ return result; }
			
			else
			{ return DateTime.MinValue; }
		}
		
	}
	
	public partial class ValidationHelper
	{
		public static IEnumerable<ErrorInfo> Validate ( object instance )
		{
			//Try to get the MetadataType attribute from the object
			MetadataTypeAttribute metadataAttrib = instance.GetType().GetCustomAttributes ( typeof ( MetadataTypeAttribute ), true ).OfType<MetadataTypeAttribute>().FirstOrDefault();
			//If the MetadataType attribute existed, get the metadata class
			//else just use the class of the object
			Type buddyClassOrModelClass = metadataAttrib != null ? metadataAttrib.MetadataClassType : instance.GetType();
			IEnumerable<System.ComponentModel.PropertyDescriptor> buddyClassProperties = System.ComponentModel.TypeDescriptor.GetProperties ( buddyClassOrModelClass ).Cast<System.ComponentModel.PropertyDescriptor>();
			IEnumerable<System.ComponentModel.PropertyDescriptor> modelClassProperties = System.ComponentModel.TypeDescriptor.GetProperties ( instance.GetType() ).Cast<System.ComponentModel.PropertyDescriptor>();
			//This query matches each property on the model class against the buddy class
			//gets a list of all invalid validation attributes and returns a list of
			//validation errors
			return from buddyProp in buddyClassProperties
			       join modelProp in modelClassProperties on buddyProp.Name equals modelProp.Name
			       from attribute in buddyProp.Attributes.OfType<ValidationAttribute>()
			       where !attribute.IsValid ( modelProp.GetValue ( instance ) )
			       select new ErrorInfo ( buddyProp.Name, attribute.FormatErrorMessage ( buddyProp.Name ), instance );
		}
	}
	public sealed class StringWriterWithEncoding : StringWriter
	{
		private readonly Encoding encoding;
		
		public StringWriterWithEncoding ( Encoding encoding )
		{
			this.encoding = encoding;
		}
		
		public override Encoding Encoding
		{
			get { return encoding; }
		}
	}
	
	public partial class ErrorInfo
	{
		public string Name { get; set; }
		public string FormatErrorMessage { get; set; }
		public object Instance { get; set; }
		
		public ErrorInfo ( string name, string formatErrorMessage, object instance )
		{
			Name = name;
			FormatErrorMessage = formatErrorMessage;
			Instance = instance;
		}
	}
	
	public static class XElementExtensions
	{
		public static byte[] DeserializeTobyteList ( this XElement element )
		{
			if ( element == null )
			{ return new byte[0]; }
			
			if ( string.IsNullOrEmpty ( element.Value ) )
			{ return new byte[0]; }
			
			return ConvertHexStringToByteArray ( element.Value );
		}
		
		public static byte[] ConvertHexStringToByteArray ( string hexString )
		{
			if ( hexString.Length % 2 != 0 )
			{
				throw new ArgumentException ( String.Format ( CultureInfo.InvariantCulture, "The binary key cannot have an odd number of digits: {0}", hexString ) );
			}
			
			var hexAsBytes = new byte[hexString.Length / 2];
			
			for ( int index = 0; index < hexAsBytes.Length; index++ )
			{
				string byteValue = hexString.Substring ( index * 2, 2 );
				hexAsBytes[index] = byte.Parse ( byteValue, NumberStyles.HexNumber, CultureInfo.InvariantCulture );
			}
			
			return hexAsBytes;
		}
		
		public static byte[] DeserializeBase64ToByteArray ( this XElement element )
		{
			if ( element == null )
			{ return new byte[0]; }
			
			if ( string.IsNullOrEmpty ( element.Value ) )
			{ return new byte[0]; }
			
			return Convert.FromBase64String ( element.Value );
		}
	}
	
}
